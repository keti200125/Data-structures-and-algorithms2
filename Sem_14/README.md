# Хеш таблица (Hash table/Hash map)

## Въведение
Хеш таблицата е структура от данни, която се състои от наредени двойки **<ключ (key), стойност (value)>** или **само от ключове** (keys).  
При хеш таблицата имаме **хешираща функция**, която при подаден ключ генерира индекс **(хеш код/hash code)**, на който трябва да се запише съответната стойност (value). По принцип, този индекс е уникален. Може, обаче, да се случи генериране на един и същ хеш код за два различни ключа, което довежда до дублиране на индекси. Този проблем е познат като **„Колизия“ (“Collision”)**.  

![alt_text](https://i.ibb.co/GtPr2ky/Hash.jpg)

## Хеш функции
Какво наричаме **"добра" хеш функция**? - функция, при която има **малка вероятност за колизия**.  
- Функцията трябва да използва **всички данни от key**.  
- За **"подобни" ключове**, функцията връща **"напълно различни" индекси**.  
- **Равномерна функция** (Броят на колизиите на всеки индекс е относително еднакъв).  
- **Бърза за изчислване**. :exclamation:  

**"Перфектна" хеш функция - никога няма колизии!**  
В реалния свят, такава функция рядко е възможно да бъде създадена (възможните слотове обикновено са значително по- малко от възможните ключове).  
***Например***, ако множеството от ключовете са стрингове с дължина 20, съставени от буквите на английската азбука, то възможните стрингове са 26\^20, а възможните слотове - 4\*(10\^12). Следователно, по Дирихле, е невъзможно да нямаме колизия, ако хешираме повече от 4\*(10\^12) елемента.  

## Хеш таблици
1. **Основни операции**  
- insert(x)  
- find(x)  
- remove(x)  

2. **Видове**  
- С ключ и стойност (**map**)  
- Само ключ (**set**)  

3. **Предимства**  

||Worst case complexity|Expected complexity||
|--|--|--|--|
|insert|O(n)|O(1)|:heavy_check_mark:|
|find|O(n)|O(1)|:heavy_check_mark:|
|remove|O(n)|O(1)|:heavy_check_mark:|

4. **Недостатъци**  
- няма наредба  
- сложност на хеш-функцията  
- операциите не винаги са константни  
- преразход на памет  
- неудобно обхождане  

## Collision resolution strategies (CRS)

### Външно хеширане/Затворено адресиране (External Hashing/Closed addressing/Separate Chaining) - Данните са извън таблицата
Таблицата е масив от „кофи“ (buckets).  
Всяка кофа е отделен контейнер (най-често списък).  
**Преоразмеряване** на таблицата при запълване над 70% чрез прехеширане на всички елементи.  

:question: Нарича се ***затворено адресиране***, защото винаги x ∈ table[h(x)].  

![alt_text](https://i.ibb.co/G0Sh7sj/Open-hashing.png)

:heavy_check_mark: Общ брой елементи, по- голям от размера на таблицата, е ок.  
:heavy_check_mark: Лесно намираме всички елементи с даден ключ.  
:heavy_check_mark: Изтриването е лесно.  
:x: Индиректен достъп до елементите.  
:x: Повече памет.  

### Вътрешно хеширане/Отворено адресиране (Closed Hashing/Open addressing) - Данните са в таблицата
Таблицата съдържа всички елементи.  
За всяка клетка има допълнителни два флага – **empty** и **deleted**.  

 **Справяне с колизии**  
 • **Линейно пробване** - Стъпката S, която избираме, трябва да бъде взаимно проста с размера n на таблицата! **(S, n) = 1** :exclamation:  
 • **Квадратично пробване**  
 • **Двойно хеширане**  
 
Други стратегии – **Ку-Ку хеширане**  

**При вътрешното хеширане sizeof(table), n > броя елементи, cnt!** :exclamation:  
Препоръка: **n > 1,5*cnt**.  

![alt_text](https://i.ibb.co/F0YLZpF/Closed-hashing.png)

:heavy_check_mark: По- малко памет.  
:heavy_check_mark: Директен достъп по index.  
:x: По- трудно изтриване.  
:x: Неконсистентни позиции.  

## Задача 1 
Даден е масив от цели числа и цяло число цел, Намерете индекси на двете числа, така че сумата им да дава целта.

Може да приемете, че всеки вход ще има точно едно решение и не можете да използвате един и същи елемент два пъти.

Пример:

Вход: числа = [2,7,11,15], цел = 9
Изход: [0,1]
Обяснение: Тъй като nums[0] + nums[1] == 9, връщаме [0, 1].

## Задача 2
Реализирайте кеш "най-отдавна използван", който премахва най-отдавна използвания елемент. Кешът трябва да пази свойки <ключ, стойност>, позволява взимането и премахването на двойка и трябва да бъде инициализиран с максимален капацитет. Когато се запълни, кешът трябва да премахне елементът, който най-отдавна е използван.

## Задача 3
 Да се дефинира шаблон Counter<T>, който реализира “преброител” на елементи от тип T. Преброителят се инициализира с нулева бройка за всички елементи от тип T и позволява да се “добавя” и “премахва” по един брой от даден елемент x на T. Шаблонът да дефинира следните операции:

-   [0.25т.] operator +=: увеличава броя на елемента x;
    
-   [0.25т.] съответен оператор +;
    
-   [0.25т.] operator -=: намалява броя на елемента x;
    
-   [0.25т.] съответен оператор -;
    
-   [0.25т.] count: Връща колко елемента имат брой, различен от 0;
    
-   [0.25т.] оператор за индексиране [x], дава броя на x;
    
-   [0.25т.] operator + за събиране на два брояча (бройките на резултатния брояч са сумите на бройките на изходните броячи).
    

Например:

Counter<int> c; c+=0; c+=0; std::cout << c[0] << “, ” << c[1];