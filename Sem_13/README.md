# Най - къси пътища в граф.
Обобщение: Разглеждаме накратко структурата от данни приоритетна опашка. Разглеждаме алгоритъма на Dijkstra и функцията relax.

## Приоритетни опашки, но накратко
В първата част на курса се запознахме със структурата от данни опашка. В приоритетната опашка отново можем да вкарваме и изваждаме елементи, но този път не излиза най - рано добавения елемент. Всеки елемент има приоритет и когато извадим елемент излиза най - приоритетния. Примерно, ако елементите ни са цели числа, можем да кажем, че колкото по - малък е един елемент толкова по - малък приоритет има той.

Такава приоритетна опашка се нарича min priority queue.

```cpp
#include<queue>
#include<iostream>

int main() {
	// * int - от какъв тип са елементите
	// * std::vector<int> - за да държи елементите тази опашка използва друг контейнер като ги нарежда хитро в него.
	// този контейнер избираме да е std::vector<int>
	// * std::less<int> - как определяме приоритета на елементите.
	std::priority_queue<int, std::vector<int>, std::less<int>> q;

	q.push(3);
	q.push(2);
	q.push(4);
	q.push(1);

	while (!q.empty()) {
		// Излиза най - приоритетния елемент в началото 4 след това 3 и тн.
		std::cout << q.top() << " ";
		q.pop();
	}
}
```

Приоритетните опашки и начинът за тяхната реализация може да отнеме един цял семинар. Може да мислите за приоритетната опашка като за абстрактен тип от данни, който поддържа някакъв интерфейс, и за който имаме различни хитри начини да бъде реализиран.

Изваждането на елемент от приоритетната опашка е със сложност O(log(n)) където n e броя на елементите в опашката. Също така можем да построим приоритетна опашка в O(n) време.

Приоритетните опашки често имат операцията decrease-key. Ако приоритетната опашка е от двойки ключ и стойност искаме да намалим ключа на дадена стойност. Тази операция е O(log(n)).

## Алгоритъм на Dijkstra
Алгоритъмът на Dijkstra намира най - къс път в ориентиран граф. **Алгоритъмът на Dijkstra не работи коректно, ако има отрицателни тегла, дори да няма отрицателни цикли!**

Коректността на алгоритъма е сравнително трудна за доказване, затова ще разгледаме примерен код.

```cpp
bool relax(std::vector<weight_t>& distance, const MatrixGraph& g, vertex_t reached, vertex_t currentVertex) {
    if (distance[reached] > distance[currentVertex] + g.getWeight(currentVertex, reached)) {
        distance[reached] = distance[currentVertex] + g.getWeight(currentVertex, reached);
        return true;
    }
    return false;
}

// Намиране на най - къс път между два върха
int Dijkstra(const MatrixGraph& g, vertex_t start, vertex_t end) {
    std::vector<vertex_t> parent(g.vertexCount(), -1);
    std::vector<weight_t> distances(g.vertexCount(), INT_MAX);

    struct VertexDistancePair {
        vertex_t vertex;
        weight_t distanceFromStart;

        bool operator<(const VertexDistancePair& other) const {
            return distanceFromStart > other.distanceFromStart;
        }
    };

    std::priority_queue<VertexDistancePair> q;

    distances[start] = 0;
    q.push({ start, 0 });

    while (!q.empty()) {
        auto currentPair = q.top();
        q.pop();

        if (currentPair.vertex == end) {
            auto currentVertex = currentPair.vertex;

            std::list<vertex_t> path;

            while (currentVertex != start) {
                path.insert(path.begin(), currentVertex);
                currentVertex = parent[currentVertex];
            }

            path.insert(path.begin(), start);

            for (const auto& v : path)
                std::cout << v << std::endl;

            return distances[currentPair.vertex];
        }

        const auto& adjacent = g.adjacent(currentPair.vertex);

        for (auto reached : adjacent) {
            if (relax(distances, g, reached, currentPair.vertex)) {
                parent[reached] = currentPair.vertex;
                q.push({ reached, distances[reached] });
            }
        }
    }

    return INT_MAX;
}
```
Функцията връща най - късия път между start и end. За да имаме този път ни трябва масив, в който ще пазим предшествениците. Този масив наричаме parent.

Ако имаме път 1 3 7, то
* parent[1] = -1
* parent[3] = 1
* parent[7] = 3

Също така в масивът distances ще записваме локално колко е цената на най - късия път от старта, открит до момента.
Нека v e връх. Сега знаем, че distances[v] e дължината на най - късия път, който сме намерили до момента. Тоест, има някакъв път s -> v.

Нека u e наследник на v. Знаем, че в distances[u] rма дължината на най - късия път, който сме открили до момента. Има два начина да стигнем до u. Първият начин е s -> u (пътят, чиято стойност е записана във distances[u]. Забележете, че ако такъв път не е открит, фактът, че стойността е INT_MAX отново води до коректно изпълнение). Вторият начин е s -> v -> u. 

Възможно ли е да сме намерили по - лек път от s -> u? Нека проверим. Тази проверка е отговорност на функцията relax:

```
relax(u, v):
    if d[u] > d[v] + weight(v, u)   // Ако пътят s -> v -> u e по - лек от пътят d[u]
        d[u] = d[v] + weight(v, u)  // Си открил нов най - лек път. Запиши го.
```

Създаваме приоритетна опашка в която ще държим наредени двойки от типа (връх, тегло на най - къс път).

Всеки път от тази опашка ще вадим **върхът с най - лек път**. Затова съзваме структурата, представляваща двойка. В приоритетната опашка пътят от старта до върха ще представлява приоритета на върха. Оригиналният алгоритъм зарежда в приоритетната опашка веднага всички върхове и ъпдейтва ключовете им директно в опашката чрез функцията decrease-key. В началото всички ключове без началния са INT_MAX и след това постепенно се прилага decrease key всеки път когато открием по - кратък път. Тук приемаме друг подход, постепенно добавяме върхове в опашката, понеже std::priority_queue не поддържа decrease key. Това ще доведе до добавяне на върха няколко пъти в опашката но с различни ключове (всеки път когато намерим по - къс път). Това обаче не прави алгоритъма некоректен, просто върти малко повече.

Сега, докато има елементи в опашката вземаме най - лекия връх v (този с минимален ключ т.е. с най - малък открит път от старта до него). За всеки негов съсед u, ако можем да го релаксираме го добавяме в опашката с разстоянието, което сме намерили. 

Когато върхът, който извадим от опашката е end в distances[end] e записан най - късия път от началото до end. Това твърдение също не е очевидно, но е вярно.

Та, когато извадим end от опашката ни остава само да възстановим пътя и да върнем неговата стойност. Извеждаме го на стандартния изход, понеже това е примерен код. След това връщаме и самата дължина. 

Използваме std::list понеже добавянето в началото е бързо, но със същия успех бихме могли да добавяме в края на вектор примерно и да го обърнем след това.

Ако искаме най - късите пътища от s до всички достижими върхове, просто ще изчакаме алгоритъма да приключи. След това ще върнем distances и parent за да можем да възстановим пътя за всеки връх.

Сложността на представената версия на Dijkstra е O(|E|log(|E|)). Сложността на оригиналната Dijkstra реализирана с binary heap е 
O(|V|log|V| + |E|log|V|)
* |V|*log(|V|) - в началото добавяме |V| елемента в приоритетната опашка. Всяко добавяне е log(|V|) време
* |E|log|V| - Можем да имаме |E| операции decrease key (ако релаксираме за всяко ребро). Всеки decrease-key е log|V|. 

С изтънчени структури от данни Dijkstra може да стане и по - бърз **асимптотично**.

![alt_text](media/dijkstra.png)

```c++
struct Edge
{
    int to;
    int weight;
};

struct Graph
{
    std::vector<std::list<Edge>> adj;

    Graph(int V) : adj(V) {};

    void addEdge(int from, int to, int w)
    {
        adj[from].push_back({ to, w });
        adj[to].push_back({ from, w });
    }
};

    Graph g(9);

    g.addEdge(0, 1, 4);
    g.addEdge(0, 7, 8);
    g.addEdge(1, 2, 8);
    g.addEdge(1, 7, 11);
    g.addEdge(2, 3, 7);
    g.addEdge(2, 8, 2);
    g.addEdge(2, 5, 4);
    g.addEdge(3, 4, 9);
    g.addEdge(3, 5, 14);
    g.addEdge(4, 5, 10);
    g.addEdge(5, 6, 2);
    g.addEdge(6, 7, 1);
    g.addEdge(6, 8, 6);
    g.addEdge(7, 8, 7);

```

## Задача 1 
Имплеметирайте Дийкстра без и с приоритетна опашка.

## Задача 2  (Контролно 2019/20)
** Нека имаме ориентиран граф от символи **g** и двоично дърво от символи **t**.  
Множеството от елементите на двете структури е едно и също, като в рамките на всяка една от структурите символите са уникални.  
Напишете функция, която *проверява дали съществува път от корена на дървото до листо, който да отговаря на път в графа*, и ако има такъв, го извежда.  
(*Заб.:* достатъчно е да изведете само един път, който отговаря на условието).  

***Пример:*** Пътят a - f - c - h отговаря на условието.  

![alt_text](https://i.ibb.co/HFJTk8d/Graph-Tree.png)

```c++
template <typename T>
struct Node
{
    T data;
    Node* left;
    Node* right;

    Node(const T& data, Node* left = nullptr, Node* right = nullptr) : data(data), left(left), right(right) {};
};

	Node<char>* root = new Node<char>('a');
	Node<char>* n1 = new Node<char>('e');
	Node<char>* n2 = new Node<char>('f');
	Node<char>* n3 = new Node<char>('d');
	Node<char>* n4 = new Node<char>('g');
	Node<char>* n5 = new Node<char>('c');
	Node<char>* n6 = new Node<char>('b');
	Node<char>* n7 = new Node<char>('h');
	root->left = n1;
	root->right = n2;
	n1->left = n3;
	n1->right = n4;
	n2->right = n5;
	n3->left = n6;
	n5->left = n7;

	Graph g;
	g.addEdge('a', 'f');
	g.addEdge('a', 'd');
	g.addEdge('b', 'h');
	g.addEdge('c', 'h');
	g.addEdge('d', 'e');
	g.addEdge('e', 'h');
	g.addEdge('f', 'h');
	g.addEdge('f', 'c');
	g.addEdge('g', 'b');
	g.addEdge('g', 'e');

	findPath(g, root);
```


## Задача 3
 От стандартния вход постъпват две естествени числа N ≤ 50 и K ≤ 2500, последвани от K на брой двойки от естествени числа (vi, ui), i = 0,...,K-1. Въведените стойности дефинират **неориентиран**  граф граф G: <V={0,...,N-1}, E={(vi, ui) | i = 0,...,K-1} U {(ui, vi) | i = 0,...,K-1}}. Да се реализира подходящо представяне на графа и за така въведения граф да се намери и изведе на стандартния изход:

1.  Броя на различните му свързани компоненти.
2.  За всяка свързана компонента да се изведе списък с върховете, които принадлежат към нея.
3.  Информацията за свързаните компоненти да се изведе подредена относно броя на елементите им.

